package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"golang.org/x/mod/semver"
)

type VulnerabilityInfo struct {
	InstalledVersions []string
	FixedVersions     []string
	ImageNames        []string
}

func generateExcelCompatibleSummary(resultsDir string) {
	fmt.Println("\nðŸ“„ Excel-Compatible Summary (Copy and Paste into Excel):")
	fmt.Println("image_name\ttotal\tunknown\tlow\tmedium\thigh\tcritical")

	files, err := os.ReadDir(resultsDir)
	if err != nil {
		fmt.Printf("âŒ Failed to read results directory %s: %v\n", resultsDir, err)
		return
	}

	summaryRegex := regexp.MustCompile(`Total:\s+(\d+)\s+\(UNKNOWN:\s+(\d+),\s+LOW:\s+(\d+),\s+MEDIUM:\s+(\d+),\s+HIGH:\s+(\d+),\s+CRITICAL:\s+(\d+)\)`)

	for _, file := range files {
		if file.IsDir() {
			continue
		}
		path := filepath.Join(resultsDir, file.Name())

		f, err := os.Open(path)
		if err != nil {
			fmt.Printf("âŒ Failed to open %s: %v\n", path, err)
			continue
		}
		defer f.Close()

		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			line := scanner.Text()
			if summaryRegex.MatchString(line) {
				matches := summaryRegex.FindStringSubmatch(line)
				image := strings.TrimSuffix(file.Name(), ".trivy")
				fmt.Printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
					image, matches[1], matches[2], matches[3], matches[4], matches[5], matches[6])
			}
		}
	}
}

func main() {
	imageFile := "images.txt"
	resultsDir := "trivy_results"
	tarballDir := "tarballs"

	vulnMap := make(map[string]VulnerabilityInfo)
	severityCounter := map[string]int{"LOW": 0, "MEDIUM": 0, "HIGH": 0, "CRITICAL": 0}

	// Create result and tarball directories if not exists
	if err := os.MkdirAll(resultsDir, 0755); err != nil {
		panic(err)
	}
	if err := os.MkdirAll(tarballDir, 0755); err != nil {
		panic(err)
	}

	// Read image list
	file, err := os.Open(imageFile)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		image := strings.TrimSpace(scanner.Text())
		if image == "" {
			continue
		}

		fmt.Printf("\nðŸ” Processing image: %s\n", image)
		safeName := strings.ReplaceAll(image, "/", "_")
		safeName = strings.ReplaceAll(safeName, ":", "_")

		tarFile := filepath.Join(tarballDir, safeName+".tar")
		outFile := filepath.Join(resultsDir, safeName+".trivy")

		// Check if image is present locally
		if err := exec.Command("docker", "image", "inspect", image).Run(); err != nil {
			fmt.Printf("ðŸ“¥ Image not found locally. Attempting to pull: %s\n", image)
			if err := runCommand("docker", "pull", image); err != nil {
				fmt.Printf("âŒ Failed to pull image %s: %v\n", image, err)
				continue
			}
		} else {
			fmt.Printf("âœ… Image found locally: %s\n", image)
		}

		// Check if tarball exists, if not create it
		if _, err := os.Stat(tarFile); os.IsNotExist(err) {
			fmt.Printf("ðŸ“¦ Creating tarball for %s...\n", image)
			if err := runCommand("docker", "save", "-o", tarFile, image); err != nil {
				fmt.Printf("âŒ Failed to save image %s to tarball: %v\n", image, err)
				continue
			}
		} else {
			fmt.Printf("ðŸ“ Tarball already exists: %s\n", tarFile)
		}

		// Run Trivy scan on tarball
		fmt.Printf("ðŸ›¡ï¸ Running Trivy scan on tarball: %s\n", tarFile)
		out, err := os.Create(outFile)
		if err != nil {
			fmt.Printf("âŒ Failed to create result file for %s: %v\n", image, err)
			continue
		}
		cmd := exec.Command("trivy", "image", "--input", tarFile, "--skip-db-update", "--scanners", "vuln")
		cmd.Stdout = out
		cmd.Stderr = os.Stderr
		cmd.Run()
		out.Close()

		parseTrivyFile(outFile, vulnMap, image)
		parseSummary(outFile, severityCounter)

	}

	// Print vulnerability info
	fmt.Println("\nðŸ“Š Final Vulnerability Map:")
	for lib, info := range vulnMap {
		fmt.Printf("%s: {Installed Version: %v, Fixed Version: %v, Image Name: %v}\n",
			lib, info.InstalledVersions, info.FixedVersions, info.ImageNames)
	}

	// Per-image summary
	fmt.Println("\nðŸ§¾ Per-image Summary from Trivy Files:")
	files, err := os.ReadDir(resultsDir)
	if err != nil {
		fmt.Printf("Failed to read directory %s: %v\n", resultsDir, err)
		return
	}
	for _, file := range files {
		if file.IsDir() {
			continue
		}
		fmt.Println("\n####################################################################################")
		fmt.Printf("TRIVY SUMMARY FOR IMAGE RESULT: %s\n", file.Name())
		cmd := exec.Command("grep", "-i", "total", "-B", "3", filepath.Join(resultsDir, file.Name()))
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Run()
	}
	fmt.Println("####################################################################################")

	checkKubernetesModules(vulnMap)

	// Print total severity summary
	fmt.Println("\nðŸ›¡ï¸  Total Vulnerability Summary:")
	fmt.Printf("LOW: %d, MEDIUM: %d, HIGH: %d, CRITICAL: %d, TOTAL: %d\n",
		severityCounter["LOW"], severityCounter["MEDIUM"], severityCounter["HIGH"], severityCounter["CRITICAL"],
		severityCounter["LOW"]+severityCounter["MEDIUM"]+severityCounter["HIGH"]+severityCounter["CRITICAL"])

	generateExcelCompatibleSummary(resultsDir)
}

func runCommand(name string, args ...string) error {
	cmd := exec.Command(name, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func appendUnique(slice []string, val string) []string {
	for _, item := range slice {
		if item == val {
			return slice
		}
	}
	return append(slice, val)
}

func parseTrivyFile(path string, vulnMap map[string]VulnerabilityInfo, image string) {
	f, err := os.Open(path)
	if err != nil {
		fmt.Printf("Failed to open %s: %v\n", path, err)
		return
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "â”‚") && !strings.Contains(line, "â”€â”€â”€") {
			fields := strings.Split(line, "â”‚")
			for i := range fields {
				fields[i] = strings.TrimSpace(fields[i])
			}
			if len(fields) >= 7 {
				lib := fields[1]
				installed := fields[5]
				fixed := fields[6]

				if lib == "" || installed == "" || fixed == "" {
					continue
				}

				info := vulnMap[lib]
				info.InstalledVersions = appendUnique(info.InstalledVersions, installed)
				info.FixedVersions = appendUnique(info.FixedVersions, fixed)
				info.ImageNames = appendUnique(info.ImageNames, image)
				vulnMap[lib] = info
			}
		}
	}
}

func parseSummary(path string, counter map[string]int) {
	f, err := os.Open(path)
	if err != nil {
		fmt.Printf("Failed to open %s: %v\n", path, err)
		return
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	re := regexp.MustCompile(`Total:\s+\d+.*LOW:\s+(\d+),\s+MEDIUM:\s+(\d+),\s+HIGH:\s+(\d+),\s+CRITICAL:\s+(\d+)`)
	for scanner.Scan() {
		line := scanner.Text()
		matches := re.FindStringSubmatch(line)
		if len(matches) == 5 {
			counter["LOW"] += atoi(matches[1])
			counter["MEDIUM"] += atoi(matches[2])
			counter["HIGH"] += atoi(matches[3])
			counter["CRITICAL"] += atoi(matches[4])
		}
	}
}

func atoi(s string) int {
	var i int
	fmt.Sscanf(s, "%d", &i)
	return i
}

func checkKubernetesModules(vulnMap map[string]VulnerabilityInfo) {
	modURL := "https://raw.githubusercontent.com/kubernetes/kubernetes/v1.31.7/go.mod"
	filename := "kubernetes_1.31.7_go.mod"

	// Download if not exists
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		fmt.Printf("\nâ¬‡ï¸ Downloading go.mod from %s\n", modURL)
		out, err := os.Create(filename)
		if err != nil {
			fmt.Printf("âŒ Failed to create go.mod file: %v\n", err)
			return
		}
		defer out.Close()

		cmd := exec.Command("curl", "-sSL", modURL)
		cmd.Stdout = out
		if err := cmd.Run(); err != nil {
			fmt.Printf("âŒ Failed to download go.mod: %v\n", err)
			return
		}
	} else {
		fmt.Printf("\nðŸ“ go.mod file already exists: %s\n", filename)
	}

	// Parse go.mod
	file, err := os.Open(filename)
	if err != nil {
		fmt.Printf("âŒ Failed to open go.mod: %v\n", err)
		return
	}
	defer file.Close()

	moduleVersions := map[string]string{}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "require") || strings.HasPrefix(line, "replace") || strings.HasPrefix(line, "module") || line == "" {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) >= 2 {
			modPath := fields[0]
			version := fields[1]
			moduleVersions[modPath] = version
		}
	}

	// Compare with Final Vulnerability Map
	fmt.Println("\nðŸ”Ž Matching Vulnerabilities with Kubernetes go.mod:")
	for lib, info := range vulnMap {
		if kubeVersion, ok := moduleVersions[lib]; ok {
			// Pick the highest fixed version
			fixed := highestSemver(info.FixedVersions)
			updatePossible := semver.Compare(fixed, kubeVersion) <= 0

			fmt.Printf("%s: {Installed: %v, Fixed: %v, Used by Kubernetes: %s, update possible: %v}\n",
				lib, info.InstalledVersions, info.FixedVersions, kubeVersion, updatePossible)
		}
	}
}

func highestSemver(versions []string) string {
	if len(versions) == 0 {
		return ""
	}
	// Ensure all start with 'v'
	normalized := make([]string, 0, len(versions))
	for _, v := range versions {
		if !strings.HasPrefix(v, "v") {
			v = "v" + v
		}
		normalized = append(normalized, v)
	}
	sort.Slice(normalized, func(i, j int) bool {
		return semver.Compare(normalized[i], normalized[j]) > 0
	})
	return normalized[0]
}
